<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yangfan-witcher.github.io","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="目录1.Redis简介2.Redis特点3.数据结构及开发细节4.安装部署过程(centos7为例)4.1.yum下载rpm包自动部署4.2.源码编译安装4.2.Docker部署Redis5.配置文件Redis.conf学习(重要配置项)6.Redis使用内存maxmemory7.Redis的两种持久化策略7.1RDB持久化7.2AOF持久化7.3持久化的选择7.4可行的Redis数据备份方案8.">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis知识点简略分享（网络文档整理+测试生产环境调参+偏架构运维方向）">
<meta property="og:url" content="https://yangfan-witcher.github.io/2020/11/10/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E7%95%A5%E5%88%86%E4%BA%AB%EF%BC%88%E7%BD%91%E7%BB%9C%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-%E6%B5%8B%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%B0%83%E5%8F%82-%E5%81%8F%E6%9E%B6%E6%9E%84%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91%EF%BC%89/index.html">
<meta property="og:site_name" content="杨 泛 walking">
<meta property="og:description" content="目录1.Redis简介2.Redis特点3.数据结构及开发细节4.安装部署过程(centos7为例)4.1.yum下载rpm包自动部署4.2.源码编译安装4.2.Docker部署Redis5.配置文件Redis.conf学习(重要配置项)6.Redis使用内存maxmemory7.Redis的两种持久化策略7.1RDB持久化7.2AOF持久化7.3持久化的选择7.4可行的Redis数据备份方案8.">
<meta property="og:image" content="https://yangfan-witcher.github.io/img/name.jpg">
<meta property="article:published_time" content="2020-11-09T16:21:30.000Z">
<meta property="article:modified_time" content="2020-11-09T16:37:51.011Z">
<meta property="article:author" content="fan yang">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yangfan-witcher.github.io/img/name.jpg">

<link rel="canonical" href="https://yangfan-witcher.github.io/2020/11/10/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E7%95%A5%E5%88%86%E4%BA%AB%EF%BC%88%E7%BD%91%E7%BB%9C%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-%E6%B5%8B%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%B0%83%E5%8F%82-%E5%81%8F%E6%9E%B6%E6%9E%84%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Redis知识点简略分享（网络文档整理+测试生产环境调参+偏架构运维方向） | 杨 泛 walking</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杨 泛 walking</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-message">

    <a href="/message/" rel="section"><i class="fa fa-fw fa-messagessss"></i>message</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://yangfan-witcher.github.io/2020/11/10/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AE%80%E7%95%A5%E5%88%86%E4%BA%AB%EF%BC%88%E7%BD%91%E7%BB%9C%E6%96%87%E6%A1%A3%E6%95%B4%E7%90%86-%E6%B5%8B%E8%AF%95%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E8%B0%83%E5%8F%82-%E5%81%8F%E6%9E%B6%E6%9E%84%E8%BF%90%E7%BB%B4%E6%96%B9%E5%90%91%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/timg.jpg">
      <meta itemprop="name" content="fan yang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨 泛 walking">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis知识点简略分享（网络文档整理+测试生产环境调参+偏架构运维方向）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-10 00:21:30 / 修改时间：00:37:51" itemprop="dateCreated datePublished" datetime="2020-11-10T00:21:30+08:00">2020-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>1.Redis简介<br>2.Redis特点<br>3.数据结构及开发细节<br>4.安装部署过程(centos7为例)<br>4.1.yum下载rpm包自动部署<br>4.2.源码编译安装<br>4.2.Docker部署Redis<br>5.配置文件Redis.conf学习(重要配置项)<br>6.Redis使用内存maxmemory<br>7.Redis的两种持久化策略<br>7.1RDB持久化<br>7.2AOF持久化<br>7.3持久化的选择<br>7.4可行的Redis数据备份方案<br>8.Redis主从复制<br>8.1.主从同步的一些特性<br>8.2.主从的增量同步和全量同步<br>8.3.info replication<br>8.4.master是否开启持久化<br>9.sentinel实现redis高可用<br>9.1.sentinel的功能<br>9.2.主观下线和客观下线<br>9.3.sentinel配置文件的重要配置项<br>10.Redis-Cluster<br>10.1.redis-cluste说明介绍<br>10.2.redis-cluster的水平扩展<br>10.3.redis-cluster测试环境搭建<br>11.参考文档</p>
<h1 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1.Redis简介"></a>1.Redis简介</h1><p>Redis是一种开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超级日志，带有半径查询和流的地理空间索引。 Redis具有内置的复制，Lua脚本，LRU逐出，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供高可用性。</p>
<h1 id="2-Redis特点"><a href="#2-Redis特点" class="headerlink" title="2.Redis特点"></a>2.Redis特点</h1><p>Redis能够提供针对k-v型值的缓存及数据存储服务，它的主要特色：<br>单进程单线程工作模式，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。<br>in-memory工作模式，Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。<br>支持数据持久化,RDB持久化与AOF持久化<br>支持主从模式(能借助sentinel实现HA)<br>支持redis-cluster集群,最大化性能开销,但是资源消耗也非常巨大。</p>
<h1 id="3-数据结构及开发细节"><a href="#3-数据结构及开发细节" class="headerlink" title="3.数据结构及开发细节"></a>3.数据结构及开发细节</h1><p>略</p>
<h1 id="4-安装部署过程-centos7为例"><a href="#4-安装部署过程-centos7为例" class="headerlink" title="4.安装部署过程(centos7为例)"></a>4.安装部署过程(centos7为例)</h1><h1 id="4-1-yum下载rpm包自动部署"><a href="#4-1-yum下载rpm包自动部署" class="headerlink" title="4.1.yum下载rpm包自动部署"></a>4.1.yum下载rpm包自动部署</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> https://dl.fedoraproject.org/pub/epel/epel-<span class="keyword">release</span>-latest<span class="number">-7.</span>noarch.rpm -y</span><br><span class="line">yum <span class="keyword">install</span> redis -y</span><br><span class="line">systemctl <span class="keyword">enable</span> redis   设置开机启动</span><br><span class="line">systemctl <span class="keyword">start</span> redis	   启动服务</span><br><span class="line">systemctl <span class="keyword">status</span> redis	   查看服务状态	</span><br><span class="line"><span class="comment">#systemctl stop redis	   停止服务</span></span><br><span class="line"><span class="comment">#systemctl restart redis   重启服务</span></span><br><span class="line"><span class="comment">#systemctl disable redis   取消开机启动</span></span><br><span class="line">firewall-cmd <span class="comment">--add-port=6379/tcp --permanent      开放6379端口监听</span></span><br><span class="line">firewall-cmd <span class="comment">--reload 							  重载策略</span></span><br></pre></td></tr></table></figure>
<h1 id="4-2-源码编译安装"><a href="#4-2-源码编译安装" class="headerlink" title="4.2.源码编译安装"></a>4.2.源码编译安装</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -<span class="keyword">y</span> install gcc pcre pcre-devel zlib zlib-devel gcc-<span class="keyword">c</span>++  openssl* epel-release <span class="keyword">make</span> jemalloc-devel <span class="keyword">perl</span> ncurses-devel</span><br><span class="line">wget http://download.redis.io/releases/redis-<span class="number">4.0</span>.<span class="number">2</span>.tar.gz</span><br><span class="line">tar zxvf redis-<span class="number">4.0</span>.<span class="number">2</span>.tar.gz</span><br><span class="line"><span class="keyword">cd</span> redis-<span class="number">4.0</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> PREFIX=/usr/local/redis install</span><br><span class="line"><span class="keyword">cp</span> ./redis.<span class="keyword">conf</span> /usr/local/redis/</span><br></pre></td></tr></table></figure>
<p>可用执行文件 /usr/local/redis/bin/</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-<span class="keyword">server</span>       服务器端</span><br><span class="line">redis-cli          客户端</span><br><span class="line">redis-benchmark    调试</span><br><span class="line">redis-<span class="keyword">check</span>-dump   数据导出</span><br><span class="line">redis-<span class="keyword">check</span>-aof    数据导入</span><br></pre></td></tr></table></figure>
<p>可以直接启动,也可以手动写systemd的service文件…</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/systemd/system/redis.service</span><br><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=redis</span><br><span class="line"><span class="attribute">After</span>=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=forking</span><br><span class="line"><span class="attribute">ExecStart</span>=/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf</span><br><span class="line"><span class="attribute">ExecStop</span>=/usr/local/redis/bin/redis-cli shutdown</span><br><span class="line"><span class="attribute">Restart</span>=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
<h1 id="4-2-Docker部署Redis"><a href="#4-2-Docker部署Redis" class="headerlink" title="4.2.Docker部署Redis"></a>4.2.Docker部署Redis</h1><p><a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener">https://hub.docker.com/_/redis</a><br>直接参照docker-redis官方镜像的文档部署即可</p>
<h1 id="5-配置文件Redis-conf学习-重要配置项"><a href="#5-配置文件Redis-conf学习-重要配置项" class="headerlink" title="5.配置文件Redis.conf学习(重要配置项)"></a>5.配置文件Redis.conf学习(重要配置项)</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">port</span> <span class="number">6379</span>   		<span class="comment">#监听端口</span></span><br><span class="line"><span class="string">timeout</span> <span class="number">0</span>   		<span class="comment">#客户端和Redis服务端的连接超时时间，默认是0，表示永不超时</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span>  		<span class="comment">#作为守护进程后台启动</span></span><br><span class="line"><span class="string">supervised</span> <span class="string">systemd</span>    <span class="comment">#通过systemd接管redis需要设置此配置项</span></span><br><span class="line"><span class="string">pidfile</span> <span class="string">/var/run/redis_6379.pid</span>   		<span class="comment">#pid文件路径</span></span><br><span class="line"><span class="string">loglevel</span> <span class="string">notice</span>  					<span class="comment">#日志级别 debug/verbose/notice/warning</span></span><br><span class="line"><span class="string">logfile</span> <span class="string">"/var/log/redis.log"</span>   		<span class="comment">#日志路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##rdb持久化策略(根据业务环境和实际需求选择是否启动rdb持久化,默认是开启的)</span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span>			<span class="comment"># 在900 秒内有一个键内容发生更改触发快照机制 </span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span>			<span class="comment"># 在300 秒内有十个键内容发生更改触发快照机制 </span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span>			<span class="comment"># 在60 秒内有一万个键内容发生更改触发快照机制 </span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">no</span>	<span class="comment">#快照出错时，是否禁止redis写入操作,默认禁止yes</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">"dump.rdb"</span>	 <span class="comment">#rdb快照文件名</span></span><br><span class="line"><span class="string">dir</span> <span class="string">"./"</span>		 <span class="comment">#快照文件保存路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##主从配置暂时略过,单机redis保持默认</span></span><br><span class="line"></span><br><span class="line"><span class="string">requirepass</span> <span class="string">"XXXX"</span> <span class="comment">#设置redis连接密码,极其重要项！</span></span><br><span class="line"><span class="string">rename-command</span> 			<span class="comment">#重命名 一些高 危命令</span></span><br><span class="line"><span class="string">maxclients</span> <span class="number">10000</span>			  <span class="comment">#最大连接客户端，默认10000</span></span><br><span class="line"><span class="string">maxmemory</span>  <span class="string">6gb</span>			<span class="comment">#最大内存使用量，</span></span><br><span class="line"><span class="string">maxmemory-policy</span> <span class="string">volatile-lru</span>	    <span class="comment">#内存使用占尽之后删除key的算法策略选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#aof持久化策略(根据业务环境和实际需求选择是否启动aof持久化,默认是关闭的)</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##cluster集群配置暂时掠过,单机及哨兵模式的redis都不用更改配置</span></span><br><span class="line"><span class="comment">##Slow log</span></span><br><span class="line"><span class="string">slowlog-log-slower-than</span> <span class="number">10000</span>  <span class="comment">#以微秒 为单位 的 慢日志记录， 为 负数会禁用慢日志，为0会记录 每个命令操作。</span></span><br><span class="line"><span class="string">slowlog-max-len</span> <span class="number">128</span> <span class="comment"># 记录多少条慢日志 保存在 队列，超出后会删除最早的，以此滚动删除</span></span><br></pre></td></tr></table></figure>
<h1 id="6-Redis使用内存maxmemory"><a href="#6-Redis使用内存maxmemory" class="headerlink" title="6.Redis使用内存maxmemory"></a>6.Redis使用内存maxmemory</h1><p>redis.conf中的maxmemory定义REdis可用最大物理内存，有多种书写方式</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxmemory <span class="number">10</span>G</span><br><span class="line">maxmemory <span class="number">10</span>GB</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;CONFIG SET maxmemory <span class="number">10</span>GB</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>没有带单位尾巴的为字节数，以B结尾的表示相应的大小。如1K表示1000字节，而1KB则为1024字节。如果maxmemory值为0，表示不做限制。<br>设置最大内存使用量的时候应该考虑到几点，不能使用全部的系统内存，需要预留一部分作为RDB持久化fork出的子进程使用，另外如果是主从模式的redis，还需要预留一部分内存用作主从的缓冲区（client-output-buffer-limit slave参数配置），该缓冲区内存不计入maxmemory中。还需要强调一点，即使关闭了RDB持久化，主从的增量同步出现问题时，需要进行全量同步时仍然会启动bgsave生成dump文件，所以可以把rdb持久化抽象理解成一个关于bgsave的自动化脚本。主从全量复制的时候也会调用到bgsave。所以综上所述，<br>–如果是单机不启动rdb持久化该值可以设置为linux系统的85-90%左右，预留一小部分给其他的用户进程/系统进程<br>–如果是单机启动rdb持久化该值可以设置为75%左右，根据rdb键值变化策略，及测试环境的性能测试和监控系统对内存的使用情况在生产中做适当调整<br>–如果是主从模式的redis实例，该值可以设置为50%-75%左右，同上在生产中做适当调整<br>–redis对内存消耗很大，系统内存越大越好。大内存可以避免大部分的运维问题。当然需要结合实际<br>需要注意的几个点，redis默认不设置最大内存使用量，也就是说写入redis的数据会一直存在内存中，并占满内存，之后所有的写入都会被redis拒绝，严重情况下会触发linux的OOM机制，导致redis宕机服务不可用的风险，当然设置故障转移可以解决，但是没有任何意义<br>那么设置了最大内存使用量之后呢，当数据存放的内存达到阈值的时候如何做处理，需要设置另外一个参数-数据淘汰策略maxmemory-policy</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#volatile-lru -&gt; Evict <span class="built_in">using</span> approximated LRU among the keys <span class="built_in">with</span> an expire <span class="built_in">set</span>.</span><br><span class="line">#allkeys-lru -&gt; Evict any key <span class="built_in">using</span> approximated LRU.</span><br><span class="line">#volatile-lfu -&gt; Evict <span class="built_in">using</span> approximated LFU among the keys <span class="built_in">with</span> an expire <span class="built_in">set</span>.</span><br><span class="line">#allkeys-lfu -&gt; Evict any key <span class="built_in">using</span> approximated LFU.</span><br><span class="line">#volatile-random -&gt; <span class="keyword">Remove</span> a random key among the ones <span class="built_in">with</span> an expire <span class="built_in">set</span>.</span><br><span class="line">#allkeys-random -&gt; <span class="keyword">Remove</span> a random key, any key.</span><br><span class="line">#volatile-ttl -&gt; <span class="keyword">Remove</span> the key <span class="built_in">with</span> the nearest expire <span class="built_in">time</span> (minor TTL)</span><br><span class="line">#noeviction -&gt; Don't evict anything, just <span class="keyword">return</span> an error on write operations.</span><br></pre></td></tr></table></figure>
<p>volatile-lru:从已设置过期时间的内存数据集中挑选最近最少使用的数据 淘汰；<br>volatile-ttl: 从已设置过期时间的内存数据集中挑选即将过期的数据 淘汰；<br>volatile-random:从已设置过期时间的内存数据集中任意挑选数据 淘汰；<br>allkeys-lru:从内存数据集中挑选最近最少使用的数据 淘汰；<br>allkeys-random:从数据集中任意挑选数据 淘汰；<br>no-enviction(驱逐)：禁止驱逐数据。（默认淘汰策略。当redis内存数据达到maxmemory，在该策略下，直接返回OOM错误）；<br>建议选择volatile-lru 或者 volatile-ttl<br>引申一点，后来在网上查询相关文档，发现数据淘汰不是按照百分百的数据排序来计算淘汰规则的，是采用的随机数据。配置文件原文：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="comment">#algorithms (in order to save memory), so you can tune it for speed or</span></span><br><span class="line"><span class="comment">#accuracy. For default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="comment">#used less recently, you can change the sample size using the following</span></span><br><span class="line"><span class="comment">#configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#The default of 5 produces good enough results. 10 Approximates very closely</span></span><br><span class="line"><span class="comment">#true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#maxmemory-samples 5</span></span><br></pre></td></tr></table></figure>
<p>Redis 的 LRU 是取出配置的数目的key，然后从中选择一个最近最不经常使用的 key 进行置换，默认的 5。 设置为10数据最准确，但花费更多的CPU性能。 3速度更快开销性能最小，但不是很准确。</p>
<h1 id="7-Redis的两种持久化策略"><a href="#7-Redis的两种持久化策略" class="headerlink" title="7.Redis的两种持久化策略"></a>7.Redis的两种持久化策略</h1><p>Redis虽然是一个内存级别的缓存程序，即 redis 是使用内存进行数据的缓存的，但是其可以将内存的数据按照一定的策略保存到硬盘上，从而实现数据持久保存的目的， redis 支持两种不同方式的数据持久化保存机制，分别是RDB和AOF。</p>
<h1 id="7-1RDB持久化"><a href="#7-1RDB持久化" class="headerlink" title="7.1RDB持久化"></a>7.1RDB持久化</h1><p>Redis默认是开启RDB持久化的。<br>RDB持久化是基于时间的快照,只保留当前最新的一次快照,特点是执行速度比较快,但是如果节点意外宕机会丢失从上次快照到当前时间快照文件未更新的数据。<br>redis早期版本是通过save实现rdb数据快照，期间会堵塞请求。<br>redis之后推出了bgsave，通过fork出一个redis子进程，不堵塞原redis请求的方式保存出一个rdb文件，redis默认执行的是bgsave，在redis命令行中也可以手动执行。（save命令是高危操作！）</p>
<p>图片来源自网络<br>rdb实现的具体过程 Redis从主进程先 fork 出一个子进程，使用写时复制机制，子进程将内存的数据保存为一个临时文件，比如 dump.rdb.temp ，当数据保存完成之后再将上一次保存的 RDB 文件替换掉，然后关闭子进程，这样可以保存每一次做RDB快照的时候保存的数据都是完整的，因为直接替换RDB文件的时候可能会出现突然断电等问题而导致 RDB 文件还没有保存完整就突然关 机停止保存而导致数据丢失的情况，可以手动将每次生成的 RDB 文件进程备份，这样可以最大化保存历史数据。<br>redis一定要关闭swap内存空间，否则严重影响性能<br>如果需要关闭持久化，注释三条关于时间周期-键值变化的save策略，放开SAVE “ “表示不启用RDB备份</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#save <span class="number">900</span> <span class="number">1</span>		</span><br><span class="line">#save <span class="number">300</span> <span class="number">10</span>	</span><br><span class="line">#save <span class="number">60</span> <span class="number">10000</span>	</span><br><span class="line">save <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>RDB 模式的优缺点：<br>优点：<br>1、RDB 快照 保存了某个时间点的数据，可以通过脚本执行 bgsave 非 阻塞 或者 save 阻塞命令自定义时间点备份，可以保留多个备份，当出现问题可以恢复到不同时间点的版本。<br>2、可以最大化 IO的性能，因为父进程在保存 RDB 文件的时候唯一要做的是 fork 出一个子进程操作，父进程无需任何的IO操作,RDB在大量数据比如几个G的数据。<br>3、在恢复大数据集时恢复的速度比AOF的快。<br>缺点：<br>1、不能实时的保存数据，实例意外宕机时会丢失自上一次执行 RDB 备份到当前的内存数据<br>2、fork出的子进程需要消耗一部分内存，系统需要预留一部分内存,极端情况下需要预留一半的内存。<br>7.2AOF持久化<br>Redis的AOF默认是关闭的<br>Redis如果同时开启rdb和aof，在重启redis时，会优先选用aof文件恢复数据</p>
<p>不同于RDB的快照式全量备份,aof持久化方式是将每一个写命令都追到加一个设置的aof文件中,全名也叫append on file,有点类似mysql的binlog。主要作用是解决了数据持久化的实时性。<br>如何开启AOF持久化</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appendonly</span> <span class="literal">yes</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br></pre></td></tr></table></figure>
<p>选择AOF持久化策略</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log. Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is "everysec", as that's usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># "no" that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">--------------------------</span></span><br><span class="line"><span class="comment"># appendfsync always			#同步持久化 每次数据变更都会被立即记录到磁盘</span></span><br><span class="line"><span class="comment"># appendfsync no				#不主动进行记录，由操作系统自动调度落盘</span></span><br><span class="line">appendfsync everysec			<span class="comment">#异步操作，每秒调用一次fsync做记录（默认策略）</span></span><br></pre></td></tr></table></figure>
<p>推荐appendfsync everysec<br>AOF的重写机制,每一次写入redis的操作都会被同步到磁盘文件中，那么时间越长，文件体积就会越大，redis提供对aof文件进行优化（同样也是fork出子进程后台重写），重写的触发条件由下面两个参数控制</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span>-aof-rewrite-percentage <span class="number">100</span></span><br><span class="line"><span class="built_in">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb</span><br></pre></td></tr></table></figure>
<p>这两个配置项的意思是，在aof文件体量超过64mb，且比上次重写后的体量增加了100%时自动触发重写。可以修改这些参数达到自己的实际要求，也可以redis命令行中手动执行”bgrewriteaof”指令，触发aof重写<br>AOF重写原理，举例<br>举个例子：<br>对一个animals键执行以下命令：<br>SADD animals “CAT”<br>SADD animals “DOG” “Tiger”<br>SREM animais “Tiger”<br>对redis的操作有三条命令，aof文件中也需要进行三次命令保存，aof重写时读取animals键的当前值，直接用<br>SADD animals “CAT” “DOG”    一条命令即可，从而减小文件体积。<br>aof重写时也不是直接操作旧的aof文件，是检查当前数据库的键值生成新的aof文件，期间的写操作写入缓存，缓存叠加新的aof文件，之后去替换旧的aof文件，网上找了一张图片，描述了重写的全过程</p>
<p>AOF 模式的优缺点：<br>优点：<br>1、使用aof持久化会让实时性更好,可以更好的保护数据不丢失；使用每秒fsync策略，也保证了redis依旧能具有很好的性能<br>2、aof有序的保存了对数据库执行的所有写入操作,这些写入操作以Redis协议的格式保存,AOF文件的内容非常容易别人读懂,对文件分析也很轻松。举个例子：如果不小心执行了Flushall命令,只要aof文件未被重写，只要停止REDIS实例，移除AOF文件末尾的FLUSHALL命令，再次启动Redis，就可以恢复数据到之前正常的状态<br>缺点：<br>1、AOF日志文件的体积会远大于RDB快照文件，数据量越大，差距越明显，即使AOF的重写已经很大程度上降低了日志文件的体积。<br>2、根据不同的fsync策略，对redis的性能影响很大，选择always时，会非常影响redis的性能，但是可以最大限度保证数据持久化的完整，选择每秒策略时，对redis写入性能的降低程度较小，但是相比于rdb，还是有些影响；选择no策略时，官方文档解释aof的速度和rdb的速度一样快，但是一般都不会选用这个策略，所以对比rdb持久化来说，aof会稍微影响一些redis的性能。</p>
<h1 id="7-3持久化的选择"><a href="#7-3持久化的选择" class="headerlink" title="7.3持久化的选择"></a>7.3持久化的选择</h1><p>以下几段摘自redis中文文档：<br>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。<br>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。<br>有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。<br>Note: 因为以上提到的种种原因， 未来我们可能会将 AOF 和 RDB 整合成单个持久化模型。 （这是一个长期计划。）</p>
<h1 id="7-4可行的Redis数据备份方案"><a href="#7-4可行的Redis数据备份方案" class="headerlink" title="7.4可行的Redis数据备份方案"></a>7.4可行的Redis数据备份方案</h1><p>开启RDB快照，根据业务数据持久化的需求，设置相应的时间-键值变化数量，的save策略，例如 save 600 1  代表每十分钟有一个键值做出变更就做一次rdb快照，之后写一个自动化拷贝数据的脚本，检测文件变化拷贝也行，定时拷贝文件也行，做到在异地/异机（可以是不同虚拟机也可以是不同数据中心）存储不同历史版本的rdb备份文件。相对安全，至少应该每天执行一次。可以完善一下脚本，对每次备份的快照文件带有描述信息，比如时间，设置一个保留时间，最新一个月/最近七天视环境而定。</p>
<h1 id="8-Redis主从复制"><a href="#8-Redis主从复制" class="headerlink" title="8.Redis主从复制"></a>8.Redis主从复制</h1><h1 id="8-1-主从同步的一些特性"><a href="#8-1-主从同步的一些特性" class="headerlink" title="8.1.主从同步的一些特性"></a>8.1.主从同步的一些特性</h1><p>配置主从同步</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line">slaveof <span class="number">30.250</span><span class="number">.60</span><span class="number">.52</span> <span class="number">6379</span></span><br><span class="line">masterauth <span class="string">"xxxxx"</span></span><br></pre></td></tr></table></figure>
<p>在从节点的配置文件中添加或者改动这两个配置项，当然也可以在命令行直接操作<br>master节点可以拥有多个slave，每个slave作为master的一个连接客户端，slave越多对master的性能消耗也越大；slave节点也可以拥有自己的slave,实现级联，在测试环境中，理论上可以实现的主从结构五花八门，但是考虑到可维护性，不必要的性能开销，以及sentinel和Redis-cluster的存在，主从结构不必太过复杂，一主一从或者一主两从即可。<br>master在主从复制整个过程中都是非堵塞的，slave仅仅作为master的一个client，master自身节点不发生故障，会一直提供服务<br>slave在主从复制大部分时候是非堵塞的，除了从节点初次同步时与全量同步的时候。</p>
<h1 id="8-2-主从的增量同步和全量同步"><a href="#8-2-主从的增量同步和全量同步" class="headerlink" title="8.2.主从的增量同步和全量同步"></a>8.2.主从的增量同步和全量同步</h1><p>Redis的主从复制采用的是从服务器（slave）自动连接并复制主服务器（master）的内容。复制过程中有几个重要机制：<br>当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， 包括客户端的写入、key 的过期或被逐出等等。<br>当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。这部分的命令流存在一个大小值，存放在master的缓存中，在主从配置的参数中中有对该参数具体的配置<br>当slave无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。这部分全量重同步也是使用了bgsave，fork出子进程制作rdb快照（即使关闭了rdb持久化功能）传输给从节点从节点加载快照文件实现全量同步。这会造成一部分网络的开销，同时需要注意的是，从节点在全量复制主节点的过程，也就是接受rdb文件（非载入文件之前可以通过配置项设置redis使用旧数据提供查询请求）-载入rdb文件-载入完成，期间，是堵塞式的，这很好理解，所有的请求会被拒绝。<br>需要注意的是全量同步带来的性能开销很大，对于master的IO都会加大负荷，生产环境除了slave第一次初始化同步时，其他时间应该尽量避免从节点进行全量同步操作，使用增量同步，一些主从参数的设置可以帮到我们。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repl-backlog-<span class="built_in">size</span></span><br></pre></td></tr></table></figure>
<p> Redis master 有一个replication ID，一个offset复制偏移量（eplication ID, offset）从节点更新数据时也会收到这些信息，共同维护，master和slave依靠这一对数据进行主从同步请求的确认及数据是否同步的标准。master的每一次数据写入都会将数据及ID和偏移量同步写入repl-backlog-size，默认是1M，实际环境需要调大。也就是说这部分的大小代表着容许着slave更长时间的掉线，但也会付出更多的内存开销，这部分内存消耗不计入maxmemory，所以具体的参数设置可以看redis的数据量增大速率，和容许的时间，假如说每分钟平均增加数据量10M，容许30分钟之内断线的slave进行增量同步，那么理论上的数值可以设置为300M。当然具体还是参照实际环境。当断开的slave重新连接时，slave会使用偏移量和master确认数据的同步状态，如果偏移量在repl-backlog-size中，那么直接同步该增量部分，如果不存在，那么进行全量同步。在高QPS的redis实例中，这项参数因在内存许可的情况下尽量调大一些，至少不应该保持默认的1M。<br> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span></span><br></pre></td></tr></table></figure><br>Redis在为了提高处理客户端请求的响应时间，做了很多优化，其中一项是server端会为客户端做了buffer缓存。<br>class ： 客户端种类，normal（普通的客户端）、slave（从库的复制客户端和MONITOR）、pubsub（发布与订阅的客户端）。<br>：若output buffer大小超过该值，Redis会立即关闭与对应client的连接<br>：若output buffer大小超过soft limit且这种情况的持续时间超过soft seconds，则Redis会关    闭与对应client的连接。<br>对于主从复制来说，这里比较重要的配置项是client-output-buffer-limit slave这个配置项代表的缓存内容主要来源于下面三个时间内所有的master数据更新操作。<br>1）master执行rdb bgsave产生snapshot的时间<br>2）master发送rdb到slave网络传输时间<br>3）slave load rdb文件把数据恢复到内存的时间<br>在高QPS的redis实例中，这项参数因在内存许可的情况下尽量也调大一些，建议设置的比backlog-size应该还要大一些例如</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br><span class="line">repl-timeout</span><br></pre></td></tr></table></figure>
<p>slave和master之间的复制超时时间，默认为60s, 推荐设置为180s；<br>a) slave角度，如果在repl-timeout时间内没有收到master SYNC传输的rdb snapshot数据，<br>b) slave角度，在repl-timeout没有收到master发送的数据包或者ping。<br>c) master角度，在repl-timeout时间没有收到REPCONF ACK确认信息。<br>当redis检测到repl-timeout超时(默认值60s)，将会关闭主从之间的连接,redis slave发起重新建立主从连接的请求。<br>对于内存数据集比较大的系统，可以增大repl-timeout参数。<br>readOnly<br>一个主从环境中，应该把从节点设置为只读模式，避免从节点不必要的写入，造成主从数据不一致，发生意外。</p>
<h1 id="8-3-info-replication"><a href="#8-3-info-replication" class="headerlink" title="8.3.info replication"></a>8.3.info replication</h1><p>主从配置成功启动之后可以在redis-cli中查看主从相关配置信息<br>slave节点</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:xx.xxx.xx<span class="number">.52</span></span><br><span class="line">master_port:<span class="number">6379</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:<span class="number">1</span></span><br><span class="line">master_sync_in_progress:<span class="number">0</span></span><br><span class="line">slave_repl_offset:<span class="number">5146618420561</span></span><br><span class="line">slave_priority:<span class="number">100</span></span><br><span class="line">slave_read_only:<span class="number">1</span></span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_replid:<span class="number">40</span>afffd3fcb179b242bc7d3b9dcc1397b14d1653</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">5146618420561</span></span><br><span class="line">second_repl_offset:<span class="number">-1</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">536870912</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">5146081549650</span></span><br><span class="line">repl_backlog_histlen:<span class="number">536870912</span></span><br><span class="line">master节点</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">2</span></span><br><span class="line">slave0:ip=xx.xxx.xx<span class="number">.50</span>,port=<span class="number">6379</span>,state=online,offset=<span class="number">5146618418004</span>,lag=<span class="number">1</span></span><br><span class="line">slave1:ip=xx.xxx.xx<span class="number">.51</span>,port=<span class="number">6379</span>,state=online,offset=<span class="number">5146618418004</span>,lag=<span class="number">1</span></span><br><span class="line">master_replid:<span class="number">40</span>afffd3fcb179b242bc7d3b9dcc1397b14d1653</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">5146618420561</span></span><br><span class="line">second_repl_offset:<span class="number">-1</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">536870912</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">5146081549650</span></span><br><span class="line">repl_backlog_histlen:<span class="number">536870912</span></span><br></pre></td></tr></table></figure>

<h1 id="8-4-master是否开启持久化"><a href="#8-4-master是否开启持久化" class="headerlink" title="8.4.master是否开启持久化"></a>8.4.master是否开启持久化</h1><p>之前在网上看到很多的帖子提议master节点关闭持久化，slave节点开启持久化，这样做的好处可以降低master节点因为开启持久化的造成的性能额外开销，这点确实没错，但是有一个严重的安全问题：<br>大家的生产环境上对redis肯定是做了自动重启的功能的，无论是由systemd接管，或者自己        制作的守护进程脚本，都可以实现对redis意外关闭之后的自动拉起，如果redis没有做持久化，理想的情况是这样<br>master意外宕机–哨兵选举或者cluster选举某一个slave为new_master–slave节点的数据仍然保留在内存和rdb文件中-old_master重启，未找到rdb持久化快照(假设也没有开启aof)，成为一个空的redis–重连成为new_master的一个slave，从new_master接受全量数据–之后配置关闭新主节点的持久化配置，开启新从节点的持久化<br>这是一套顺利的流程，但是如果中间的某些环节出现的问题，比如因为一些错误的主从配置导致主从切换失败；因为监控的不给力，从节点在切换之前down机了，已经丧失了最新的rdb快照；数据量不大的时候redis自动重启的非常快，因为某些原因，哨兵或者cluster没有监测到redis-master已经重启了并且是一个空的master；等等一些可能的原因，上述故障一旦发生，整个过程会被破坏，master节点重启后数据为空，slave节点会同步复制master节点的数据，但是master节点的数据是空的，结果是slave会销毁自身在内存中的所有数据，包括rdb副本!这是非常严重的后果，尽管在正式环境中，一般不会发生 主从配置出错/哨兵没有切换redis 这种情况，但是为了减少master持久化带来的性能开销去冒一个这么大的风险，不太稳妥。</p>
<h1 id="9-sentinel实现redis高可用"><a href="#9-sentinel实现redis高可用" class="headerlink" title="9.sentinel实现redis高可用"></a>9.sentinel实现redis高可用</h1><h1 id="9-1-sentinel的功能"><a href="#9-1-sentinel的功能" class="headerlink" title="9.1.sentinel的功能"></a>9.1.sentinel的功能</h1><p>sentinel是Redis官方的一个小型应用管理系统，用来管理监控单个或多个Redis实例<br>sentinel会不断的检查监控的实例主从是否运行正常，当被监控的某个Redis出现问题时,sentinel可以通过API发出通知，并且当master实例不能正常工作时,会自动开始一次故障迁移操作，哨兵会将失效master的其中一个slave升级为新的master，其他salve改为复制新的master服务器。<br>故障转移自动迁移，无需人工干预，客户端只需要连接sentinel的工作端口，sentinel会在故障转移之后，对客户端新的请求返回新主服务器的地址，客户端无需变更。</p>
<h1 id="9-2-主观下线和客观下线"><a href="#9-2-主观下线和客观下线" class="headerlink" title="9.2.主观下线和客观下线"></a>9.2.主观下线和客观下线</h1><p>redis通过sentinel可以实现高可用，但是sentinel也是一个应用进程，也存在单点故障的问题，并且单台的sentinel可能因为网络原因或者其他问题存在误判的可能，那么sentinel也需要部署高可用的集群，因为sentinel在选举领导者的时候需要超过半数+1（2/2+1）的投票，所以两台sentinel的情况下如果有一台宕机就无法选举成功，也无法正常提供故障转移的工作处理，同时为了避免脑裂问题，一般情况下部署为奇数节点，所以3台，5台都是很好的选择（这一点和zookeeper，es的master是属于同种情况）sentinel之间也会形成一个集群，节点间互相监控。<br>每一台sentinel都会定期向监控目标发送一个ping命令，当主服务器回复的命令无效或者未在down-after-milliseconds 选项所指定的时间值内回复，master服务器会被这台sentinel标记为主观下线，同时对所有sentinel发出成为sentinel领导者的请求，所有sentinel中超过半数+1（3/2+1~=2）也就是两台的许可，成为新的领导者，另外所有sentinel都会加速进行确认master的目前状态，并于这台sentinel也就是新的领导者进行协商<br>–当有足够数量（至少要达到配置文件指定的数量）的sentinel都对master做出主观下线的标记，那么master会被标记为客观下线，由新的领导者sentinel对失效的主服务器执行自动故障迁移操作。<br>–当其他sentinel能够与master进行正常的通信，或者没有达到足够的数量的情况下，并不能认为客观下线，也不会发生故障迁移。</p>
<h1 id="9-3-sentinel配置文件的重要配置项"><a href="#9-3-sentinel配置文件的重要配置项" class="headerlink" title="9.3.sentinel配置文件的重要配置项"></a>9.3.sentinel配置文件的重要配置项</h1><p>配置sentinel之前必须配置好redis的主从配置，启动sentinel之后，sentienl会接管sentinel.conf及redis.conf，实现redis故障时主从切换之后对redis.conf的持久化，所以必须设置两个配置文件可写入。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel<span class="built_in"> monitor </span>mymaster 172.16.1.200 6379 2</span><br></pre></td></tr></table></figure>
<p>#配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，172.16.1.200代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。sentinel.conf中不需要填写slave的地址，也不需要填写其他sentinel节点的地址，sentinel会连接master自动订阅该master的slave节点，及连接上此redis的其他sentinel节点形成通讯。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel auth-pass mymaster <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>#sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码（根据生产环境更改）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">logfile</span> <span class="string">"/var/log/sentinel.log"</span></span><br></pre></td></tr></table></figure>
<p>#sentinel的所有监控日志，工作记录，故障转移流程日志都会记录在这个日志下，建议设置自己常用的日志路径。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">daemonize</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>开启sentinel守护进程后台启动。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-<span class="keyword">after</span>-<span class="built_in">milliseconds</span> mymaster <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>#选项指定了 Sentinel 认为服务器已经断线所需的毫秒数。默认是60s?30s?redis版本不同这个参数貌似默认值也不同，不过在实际生产环境中，这样的时间一般都太长了，如果master宕机了，需要等待60s才能故障转移时间太长，同时为了避免网络抖动或者其他原因，设置在5-10s左右差不多的样子。<br>#启动哨兵进程</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./redis-sentinel</span> <span class="string">../sentinel.conf</span></span><br></pre></td></tr></table></figure>
<p>查看哨兵信息</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -p <span class="number">26379</span> info sentinel</span><br><span class="line">#Sentinel</span><br><span class="line">sentinel_masters:<span class="number">1</span></span><br><span class="line">sentinel_tilt:<span class="number">0</span></span><br><span class="line">sentinel_running_scripts:<span class="number">0</span></span><br><span class="line">sentinel_scripts_queue_length:<span class="number">0</span></span><br><span class="line">sentinel_simulate_failure_flags:<span class="number">0</span></span><br><span class="line">master0:name=mymaster,status=ok,address=xx.xxx.xx<span class="number">.52</span>:<span class="number">6379</span>,slaves=<span class="number">2</span>,sentinels=<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>网上关于哨兵架构的文档非常的多，说的也非常详细，我这边只是笼统的归纳简单的介绍了下，整理文档的时候发现有几个帖子说的非常的好，非常的详细。<br><a href="https://www.cnblogs.com/kevingrace/p/9004460.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/9004460.html</a><br>（Redis哨兵模式（sentinel）学习总结及部署记录（主从复制、读写分离、主从切换））<br><a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a><br>Redis哨兵（Sentinel）模式</p>
<h1 id="10-Redis-Cluster"><a href="#10-Redis-Cluster" class="headerlink" title="10.Redis-Cluster"></a>10.Redis-Cluster</h1><h1 id="10-1-redis-cluste说明介绍"><a href="#10-1-redis-cluste说明介绍" class="headerlink" title="10.1.redis-cluste说明介绍"></a>10.1.redis-cluste说明介绍</h1><p>业务数据量庞大，或者有线性拓展需求可以考虑上redis官方提供的redis-cluster集群架构。<br>redis-cluster的数据分片，在集群中引入了哈希槽的概念。原先数据只能存放在一台单机上，现在存放在三台节点上，从理论上来说，自然存储的数据量级就会增大。集群中由16384个哈希槽，集群中每一个节点负责一部分hash槽，假设集群中由三个主节点那么：<br>节点 A 包含 0 到 5500号哈希槽.<br>节点 B 包含5501 到 11000 号哈希槽.<br>节点 C 包含11001 到 16384号哈希槽.<br>节点D是节点A的从节点<br>节点E是节点B的从节点<br>节点F是节点C的从节点<br>数据存储位置整体被切割成三块槽位。每一块相对独立，不过和别的分布式集群的副本的概念不完全同（es的分片副本，hdfs的block块副本），redis-cluster是直接使用主从的方法，用节点D,E,F分别作为ABC的节点的从节点做对应那一部分哈希槽的数据备份，比如承担了0-5500哈希槽的节点Adown机之后，D节点就会提升为主，接管0-5500哈希槽的请求，从而实现整个集群的高可用。<br>有个关键点在于，假如cluster只是单纯的cluster设计，不包含每个节点的从节点，那么当其中A节点出现问题时，0-5500哈希槽是无法提供工作，即使理论上5501到16384的哈希槽是可以处理落在他们之上的key的请求的，但是这个集群已经是存在重大问题了，这个时候的集群也是无法正常工作的。所以集群中的各个节点都必须要有1个或者多个slave节点。至于redis-cluster为什么至少需要三台master节点，这个可以参考sentinel模式中的哨兵选举，redis-cluster中没有sentinel，选举由master节点来完成，所以cluster中至少需要三台master，每台master必须要有自己的slave节点完成高可用，所以一个健康的redis-cluster至少需要六台实例。<br>尽量每一台实例独立运行不同的服务器上，如果一定要在单台服务器上部署多个实例，尤其是slave节点，千万千万不能把cluster中的A节点的主和从都部署在同一台服务器或者虚拟机上，应该错开，比如a节点的从实例和b节点的主实例部署在一起，不然在A节点所在的服务器宕机之后，他的slave节点也跟着宕机了，那部分的bash槽仍然是不可用的，这样的架构就是存在严重的问题。完全不是高可用了。所以交叉添加从节点，不能主从在同一台节点上。配置充足的情况下还是建议一台主一台服务器一台从一台服务器。</p>
<h1 id="10-2-redis-cluster的水平扩展"><a href="#10-2-redis-cluster的水平扩展" class="headerlink" title="10.2.redis-cluster的水平扩展"></a>10.2.redis-cluster的水平扩展</h1><p>cluster非常强大的功能还在于它的水平拓展能力，可以根据业务需求动态热添加/删除节点，同样也是无中心的架构。<br>当动态添加或减少node节点时，需要将16384个槽做个再分配，槽中的键值也要迁移。这一过程，还处于半自动状态，需要人工介入。<br>新增一个节点D，redis cluster的做法是从各个节点的前面各拿取一部分slot到D上。大致就会变成这样：<br>节点A覆盖1365-5460<br>节点B覆盖6827-10922<br>节点C覆盖12288-16383<br>节点D覆盖0-1364,5461-6826,10923-12287<br>如果是删除一个主节点<br>需要先将节点的数据移动到其他节点上，然后才能执行删除</p>
<h1 id="10-3-redis-cluster测试环境搭建"><a href="#10-3-redis-cluster测试环境搭建" class="headerlink" title="10.3.redis-cluster测试环境搭建"></a>10.3.redis-cluster测试环境搭建</h1><p>测试环境用一台虚拟机搭建一下三主三从架构的redis-cluster吧<br>先执行redis单机的编译部署安装，拿到redis源码包目录下的redis.conf和src目录下的redis.server 以及redis提供的cluster创建脚本src目录下redis-trib.rb</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /home/tool</span><br><span class="line">mkdir cluster</span><br><span class="line">cd cluster</span><br><span class="line">mkdir <span class="number">7000</span> <span class="number">7001</span> <span class="number">7002</span> <span class="number">7003</span> <span class="number">7004</span> <span class="number">7005</span></span><br><span class="line">cp /home/tool/redis<span class="number">-4.0</span><span class="number">.2</span>/redis.conf ./</span><br><span class="line">cp /home/tool/redis<span class="number">-4.0</span><span class="number">.2</span>/src/redis-server ./</span><br><span class="line">cp /home/tool/redis<span class="number">-4.0</span><span class="number">.2</span>/src/redis-trib.rb ./</span><br><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">port=<span class="number">7000</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis_7000.pid</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes<span class="number">-7000.</span>conf</span><br><span class="line">:wq</span><br></pre></td></tr></table></figure>
<p>##简单配置，不做过多优化<br>目录结构可以是这样</p>
<p>可以把redis.conf一个个cp进去，vim更改，也可以直接sed</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost cluster]# cp redis.conf <span class="number">7000</span></span><br><span class="line">[<span class="symbol">root@</span>localhost cluster]# sed -i s/<span class="number">7000</span>/<span class="number">7001</span>/g <span class="number">7001</span>/redis.conf</span><br></pre></td></tr></table></figure>
<p>然后全部启动</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost cluster]# cd <span class="number">7000</span></span><br><span class="line">[<span class="symbol">root@</span>localhost <span class="number">7000</span>]# ../redis-server ./redis.conf</span><br><span class="line">....</span><br><span class="line">[<span class="symbol">root@</span>localhost cluster]# cd <span class="number">7005</span></span><br><span class="line">[<span class="symbol">root@</span>localhost <span class="number">7005</span>]# ../redis-server ./redis.conf</span><br><span class="line"></span><br><span class="line">netstat -nltp 检查redis启动情况</span><br></pre></td></tr></table></figure>
<p>然后运行redis-trib.rb<br>localhost cluster]# ./redis-trib.rb create –replicas 1 172.16.10.205:7000 172.16.10.205:7001 172.16.10.205:7002 172.16.10.205:7003 172.16.10.205:7004 172.16.10.205:7005<br>/usr/bin/env: ruby: 没有那个文件或目录<br>不过脚本需要nuby环境及一大堆依赖。yum安装的ruby版本太低了，网上随便找了个文档安装高版本ruby，直接复制命令吧（redis5.0之后的版本不在使用这个脚本管理，不需要ruby环境，直接使用redis-cli，redis的实际使用版本看公司环境）<br>1.安装curl</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> curl</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>安装RVM<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="keyword">get</span>.rvm.io | bash -s <span class="keyword">stable</span></span><br></pre></td></tr></table></figure>
##报错<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg2 <span class="params">--keyserver</span> hkp:<span class="string">//pool.sks-keyservers.net</span> <span class="params">--recv-keys</span> 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB</span><br><span class="line"></span><br><span class="line">curl -L get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/usr/</span>local<span class="regexp">/rvm/</span>scripts<span class="regexp">/rvm</span></span><br></pre></td></tr></table></figure></li>
<li>查看rvm库中已知的ruby版本<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm <span class="built_in">list</span> known</span><br></pre></td></tr></table></figure></li>
<li>安装一个ruby版本<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm install <span class="number">2.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure></li>
<li>使用一个ruby版本<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rvm use <span class="number">2.3</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>
[root@localhost cluster]# ruby –version<br>ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-linux]<br>安装ruby的方式多种多样，能用就行。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost cluster]# gem install redis -v <span class="number">4.0</span><span class="number">.2</span></span><br><span class="line">Fetching redis<span class="number">-4.0</span><span class="number">.2</span>.gem</span><br><span class="line">Successfully installed redis<span class="number">-4.0</span><span class="number">.2</span></span><br><span class="line">Parsing documentation <span class="keyword">for</span> redis<span class="number">-4.0</span><span class="number">.2</span></span><br><span class="line">Installing ri documentation <span class="keyword">for</span> redis<span class="number">-4.0</span><span class="number">.2</span></span><br><span class="line">Done installing documentation <span class="keyword">for</span> redis after <span class="number">1</span> seconds</span><br><span class="line"><span class="number">1</span> gem installed</span><br><span class="line">[<span class="symbol">root@</span>localhost cluster]#</span><br></pre></td></tr></table></figure>
之后执行脚本创建cluster<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">root@</span>localhost cluster]# ./redis-trib.rb create --replicas <span class="number">1</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7000</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7001</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7002</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7003</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7004</span> <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7005</span></span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on <span class="number">6</span> nodes...</span><br><span class="line">Using <span class="number">3</span> masters:</span><br><span class="line"><span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7000</span></span><br><span class="line"><span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7001</span></span><br><span class="line"><span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7002</span></span><br><span class="line">Adding replica <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7003</span> to <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7000</span></span><br><span class="line">Adding replica <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7004</span> to <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7001</span></span><br><span class="line">Adding replica <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7005</span> to <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7002</span></span><br><span class="line">M: de1afd70acda5f26e5759ca1b3d0bf4a50fb82d7 <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7000</span></span><br><span class="line">   slots:<span class="number">0</span><span class="number">-5460</span> (<span class="number">5461</span> slots) master</span><br><span class="line">M: <span class="number">655f</span>ef105e714440fe5f0a26a57d4b813c742cc5 <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7001</span></span><br><span class="line">   slots:<span class="number">5461</span><span class="number">-10922</span> (<span class="number">5462</span> slots) master</span><br><span class="line">M: <span class="number">4</span>ea2c58883269239272f438b6d768b13bd89f58b <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7002</span></span><br><span class="line">   slots:<span class="number">10923</span><span class="number">-16383</span> (<span class="number">5461</span> slots) master</span><br><span class="line">S: d6f0151f1b0d20ea8247cdf4cdd9e9b650aa6d79 <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7003</span></span><br><span class="line">   replicates de1afd70acda5f26e5759ca1b3d0bf4a50fb82d7</span><br><span class="line">S: <span class="number">47671</span>cd30e75fcb2c8ef4f0ad82c76e34ef76ebb <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7004</span></span><br><span class="line">   replicates <span class="number">655f</span>ef105e714440fe5f0a26a57d4b813c742cc5</span><br><span class="line">S: fb7f54525733debd1f2882ad7d48da2e44fc8a8e <span class="number">172.16</span><span class="number">.10</span><span class="number">.205</span>:<span class="number">7005</span></span><br><span class="line">   replicates <span class="number">4</span>ea2c58883269239272f438b6d768b13bd89f58b</span><br><span class="line">Can I <span class="keyword">set</span> the above configuration? (type <span class="string">'yes'</span> to accept):</span><br></pre></td></tr></table></figure>
输入yes</li>
</ol>
<p>出现这样的提示就是创建成功了。<br>查看集群info</p>
<p>集群管理还有很多的功能就不再这里测试了。<br>集群还有很多其他的功能和原理，因为涉猎不深，之后有时间再整理。</p>
<h1 id="11-参考文档"><a href="#11-参考文档" class="headerlink" title="11.参考文档"></a>11.参考文档</h1><p><a href="https://www.cnblogs.com/zdm-code/p/12411227.html（AOF重写方面）" target="_blank" rel="noopener">https://www.cnblogs.com/zdm-code/p/12411227.html（AOF重写方面）</a><br><a href="https://www.cnblogs.com/kevingrace/p/9004460.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/9004460.html</a> （redis哨兵模式）<br><a href="http://www.redis.cn/documentation.html（redis中国文档中心，推荐，对于redis的大多数功能都有很详细的参考说明）" target="_blank" rel="noopener">http://www.redis.cn/documentation.html（redis中国文档中心，推荐，对于redis的大多数功能都有很详细的参考说明）</a></p>
<!--添加图片-->
<p><img src="/img/name.jpg" alt=""></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/27/kafka-dell-2020-6-24/" rel="prev" title="kafka的一个坑6.24">
      <i class="fa fa-chevron-left"></i> kafka的一个坑6.24
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/10/lvs%E5%92%8Cnginx%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-keepalived%E5%AE%9E%E7%8E%B0nat%E6%A8%A1%E5%BC%8F%E7%9A%84lvs%E9%AB%98%E5%8F%AF%E7%94%A8/" rel="next" title="lvs和nginx实现负载均衡+keepalived实现nat模式的lvs高可用">
      lvs和nginx实现负载均衡+keepalived实现nat模式的lvs高可用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#目录"><span class="nav-number">1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Redis简介"><span class="nav-number">2.</span> <span class="nav-text">1.Redis简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Redis特点"><span class="nav-number">3.</span> <span class="nav-text">2.Redis特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-数据结构及开发细节"><span class="nav-number">4.</span> <span class="nav-text">3.数据结构及开发细节</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-安装部署过程-centos7为例"><span class="nav-number">5.</span> <span class="nav-text">4.安装部署过程(centos7为例)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1-yum下载rpm包自动部署"><span class="nav-number">6.</span> <span class="nav-text">4.1.yum下载rpm包自动部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2-源码编译安装"><span class="nav-number">7.</span> <span class="nav-text">4.2.源码编译安装</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2-Docker部署Redis"><span class="nav-number">8.</span> <span class="nav-text">4.2.Docker部署Redis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-配置文件Redis-conf学习-重要配置项"><span class="nav-number">9.</span> <span class="nav-text">5.配置文件Redis.conf学习(重要配置项)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Redis使用内存maxmemory"><span class="nav-number">10.</span> <span class="nav-text">6.Redis使用内存maxmemory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Redis的两种持久化策略"><span class="nav-number">11.</span> <span class="nav-text">7.Redis的两种持久化策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1RDB持久化"><span class="nav-number">12.</span> <span class="nav-text">7.1RDB持久化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-3持久化的选择"><span class="nav-number">13.</span> <span class="nav-text">7.3持久化的选择</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-4可行的Redis数据备份方案"><span class="nav-number">14.</span> <span class="nav-text">7.4可行的Redis数据备份方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Redis主从复制"><span class="nav-number">15.</span> <span class="nav-text">8.Redis主从复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-1-主从同步的一些特性"><span class="nav-number">16.</span> <span class="nav-text">8.1.主从同步的一些特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-2-主从的增量同步和全量同步"><span class="nav-number">17.</span> <span class="nav-text">8.2.主从的增量同步和全量同步</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-3-info-replication"><span class="nav-number">18.</span> <span class="nav-text">8.3.info replication</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-4-master是否开启持久化"><span class="nav-number">19.</span> <span class="nav-text">8.4.master是否开启持久化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-sentinel实现redis高可用"><span class="nav-number">20.</span> <span class="nav-text">9.sentinel实现redis高可用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-1-sentinel的功能"><span class="nav-number">21.</span> <span class="nav-text">9.1.sentinel的功能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-2-主观下线和客观下线"><span class="nav-number">22.</span> <span class="nav-text">9.2.主观下线和客观下线</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-3-sentinel配置文件的重要配置项"><span class="nav-number">23.</span> <span class="nav-text">9.3.sentinel配置文件的重要配置项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Redis-Cluster"><span class="nav-number">24.</span> <span class="nav-text">10.Redis-Cluster</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-1-redis-cluste说明介绍"><span class="nav-number">25.</span> <span class="nav-text">10.1.redis-cluste说明介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-2-redis-cluster的水平扩展"><span class="nav-number">26.</span> <span class="nav-text">10.2.redis-cluster的水平扩展</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-3-redis-cluster测试环境搭建"><span class="nav-number">27.</span> <span class="nav-text">10.3.redis-cluster测试环境搭建</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-参考文档"><span class="nav-number">28.</span> <span class="nav-text">11.参考文档</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="fan yang"
      src="/uploads/timg.jpg">
  <p class="site-author-name" itemprop="name">fan yang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fan yang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
